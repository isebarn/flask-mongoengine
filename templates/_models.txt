# Standard library imports
from json import loads
from json import load
import os
from pprint import pformat

# Third party imports
from bson import json_util
from mongoengine import connect
from mongoengine import DateTimeField
from mongoengine import Document
from mongoengine import FloatField
from mongoengine import BooleanField
from mongoengine import ReferenceField
from mongoengine import StringField
from mongoengine import signals

user = os.environ.get("DB_USER", "")
password = os.environ.get("DB_PWD", "")
host = os.environ.get("DB_HOST") or "mongodb+srv://{}".format(host)
database_name = os.environ.get("DB_NAME", "")
db = connect(db=database_name, username=user, password=password, host=host)

class Extended(Document):
    meta = {"abstract": True, "allow_inheritance": True}

    def __init__(self, *args, **kwargs):
        if "id" in kwargs:
            super(Document, self).__init__(*args, **kwargs)

        else:  # Create new document and recursively create or link to existing ReferenceField docs
            super(Document, self).__init__(
                *args, **{k: v for k, v in kwargs.items() if not isinstance(v, dict)}
            )
            for key, value in self._fields.items():
                if isinstance(value, ReferenceField) and key in kwargs:
                    # link to existing
                    if isinstance(kwargs[key], Document):
                        setattr(self, key, kwargs[key])
                    elif "_id" in kwargs[key]:
                        setattr(
                            self,
                            key,
                            value.document_type_obj.objects.get(id=kwargs[key]["_id"]),
                        )
                    # create new ReferenceField
                    else:
                        setattr(self, key, value.document_type_obj(**kwargs[key]))

            self.save()

    def to_json(self):
        return {
            **loads(json_util.dumps(self.to_mongo())),
            **{
                key: getattr(self, key).to_json()
                for key, value in self._fields.items()
                if isinstance(value, ReferenceField) and getattr(self, key)
            },
        }

    @classmethod
    def set(cls, *args, **kwargs):
        _id = kwargs.pop("_id")
        item = cls.objects.get(id=_id["$oid"])
        for key, value in kwargs.items():
            prop = globals()[value["_cls"]].objects.get(id=value["_id"]["$oid"])
            setattr(item, key, prop)

        item.save()
        return cls.objects.get(id=_id["$oid"])

    @classmethod
    def get(cls, *args, **kwargs):
        def recursively_query(model, fields, search, root=False):
            if "__" not in fields:
                if root:
                    return {fields: search}

                return [x.id for x in model.objects(**{fields: search})]

            prop, fields = fields.split("__", 1)
            result = recursively_query(
                model._fields[prop].document_type_obj, fields, search
            )

            if not root:
                return [x.id for x in model.objects(**{"{}__in".format(prop): result})]
            else:
                return {"{}__in".format(prop): result}

        filters = {}
        for query, search in kwargs.items():
            filters.update(recursively_query(cls, query, search, True))

        return [x.to_json() for x in cls.objects(**filters)]

    @classmethod
    def post_save(cls, sender, document, **kwargs):
        if kwargs.get("created"):
            pass

    @classmethod
    def pre_save(cls, sender, document, **kwargs):
        if (
            document.to_json().get("_id")
            and next(cls.objects(id=document.id)).status is not document.status
        ):
            pass

